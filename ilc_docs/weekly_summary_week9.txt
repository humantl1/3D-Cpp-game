Tim Benton
3D Game Architecture II & Full Stack Dev
Summer, 2021
Week 9 summary

Brief:
Full Stack: I finished the python section this week, wrapping up with a
final python project using the techniques I learned over the previous two weeks.
For my learning, I covered topics such as classes, the self keyword, class
methods, class members, decorators, errors and exceptions, generators, and
pipenv for virtual environments. My project was a console "banking app" with
functionality to create multiple accounts, track balance, withdraw, deposit, and
record transactions and accounts to files. In addition, I briefly covered basic
SQL functionality, in order to at least be familiar with core functionality.

Game dev: This week I tried to sort through the what should be a game entity
versus what should exist outside of the entity system. For example, should the
camera be an entity? If so, what components (functionality) comprise the camera
that uniquely defines it as a camera? Considering this functionality, will there
only be one camera? If the camera has unique functionality will it only ever
exist in one static instance of a camera? If so, then is there any need to
include it in the entity-component system?

What I learned:
I continued to be amazed at the clarity and conciseness of python syntax. File
manipulation was extremely concise, and not directly dealing with streams
allowed me to spend time developing more functionality. Safe file closing using
the 'with' keyword is a nice bonus. Being used to the c++ header/source/main
file paradigm, and to some extent the c++/java class/main entry point paradigm,
I still find it awkward to structure looser paradigms such as JavaScript and
Python.

As a kind of meta discussion of software architecture, I found that my struggle
deciding how functionality should be organized and inter-related in my engines
was in a category of problems very similar to those in seemingly unrelated
fields like fine art or social sciences. To take visual art, for example,
academic discussions often center on creating definitions for previously
undefined relationships between things as esoteric as color, symbolism, and
density. These definitions then create the working vocabulary that we use to
categorize, discuss, and understand art. At first glance it would seem that
no two people would arrive at the same conclusions when interpretting things
such as color and line weight, but experts often do mangage to do just that.
This reminded me of planning the structure of code because there are many ways
one could argue functionality is related, or, say, how dependencies should be
laid out. But, after research, common agreements on structure are found. I
find this linking of seemingly undefined relationships into cohesive structure
the most challenging form of problem solving I've encountered.